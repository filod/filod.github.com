
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>从网页（Web page）到 应用（APP） - filod's not here</title>
  <meta name="author" content="filod">

  
  <meta name="description" content="从网页（Web page）到 应用（APP） Web 不能承受之重 Web的轻与重 Web 一词在英文中的本意是网络、结网，而这个网络的节点，便是网页（Web page），在过去，网页通常就是一篇文档（Document），通常来说是 HTML 文档，当然也可以是其他类型的文档（PDF、XML、 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://filod.github.com/blog/2012/10/24/cong-wang-ye-%28web-page%29dao-ying-yong-%28app%29/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="filod's not here" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-21901481-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">filod's not here</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:filod.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/guan-yu-wo">关于，我</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">从网页（Web Page）到 应用（APP）</h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-10-24T10:19:00+08:00" pubdate data-updated="true">2012-10-24</time>
        
         | <a href="#disqus_thread">评论</a>
        
      </p>
    
  </header>


<div class="entry-content"><h2>从网页（Web page）到 应用（APP）</h2>

<h3>Web 不能承受之重</h3>

<h4>Web的轻与重</h4>

<p>Web 一词在英文中的本意是网络、结网，而这个网络的节点，便是网页（Web page），在过去，网页通常就是一篇文档（Document），通常来说是 HTML 文档，当然也可以是其他类型的文档（PDF、XML、SVG等）。一篇文档就像一张纸一样，轻而薄，包含一定量的信息，通过互联网，这些信息被链接起来，供人分享和查阅——这便是最初的 Web ，一个轻巧而单纯的网络，但人们发现互联网这个好东西不只是能用来交换信息，它还可以做更多的事儿，于是 渐渐地 Web 被赋予了更多的职能：从学术论文的交流到普通人博客的撰写、从文献索引到网络购物、从邮件到论坛……功能越来越多，网页也越来越复杂，越来越重，整个Web似乎都在朝着客户端软件发展。</p>

<h4>整个世界都在APP</h4>

<p>为了满足人们对 Web 日益增长的需求，浏览器的功能也变得越来越强大，从最初只能看看文档的“浏览”器，到如今已成为和操作系统平级的系统软件（Chrome OS 便是一个旗帜鲜明的例子），浏览器的发展的迅猛与Web标准发展的迟滞形成了鲜明对比，而HTML5则成为推动标准迅速演进的重要转折点，HTML5标准中提出的一些特性使得实现复杂用户界面的Web程序更加容易和高效，例如applicationcache、manifest、localStorage等技术使基于浏览器的离线应用成为可能，定位API(geolocation api)可以轻松获取设备的地理位置，触摸事件让用户在网页上也可以做出手势指令……所有这一切技术似乎都意味这一件事情：浏览器APP的时代，已经悄然到来。</p>

<h3>本地存储升级</h3>

<h4>cookie 和 cookie 的局限</h4>

<p>HTTP 本身是一种无状态、无连接的协议，用户在浏览器上请求一个动作时，服务器不会知道用户上次动作做了什么，因此如果要存储诸如登录与否、已录入文本等状态信息是非常麻烦的，对于开发交互式的程序来说这很致命，而cookie技术的发明则满足了大部分的状态存储的需求。
从根本上来讲，cookie 其实就是一段存储在客户端（浏览器）的文本，我们既可以在服务器响应返回时设置cookie的值，也可以在前端通过 JavaScript 进行修改。</p>

<p>我们考虑一个最简单的登录场景来说明 cookie 是如何实现状态存储的，当你向百度服务器发送了你的用户名密码并且验证过你的身份之后，服务器端会在响应客户端时的 HTTP 包的包头中的加上一个cookie字段，这个字段则可能是类似 uid=123 的值，是服务器分配给你的标识符，这段文本将存储在你的计算机磁盘中，当你继续浏览百度的其他页面时，每次http请求都会带上cookie这个字段，这样服务器端就可以确认这个请求依然来自于登录后的你，从而从某种意义上来说“保存”了登录状态，这时读者可能要问了，不同网站登录时都会发送吗？那岂不是谷歌就可以知道我百度的账号了？当然不是，cookie的使用是有限制的，这个限制便来自于域，不同域间的cookie是不会影响也不可访问。（注：域限制是Cookie安全的基础，这个话题有很多值得深入讨论的点，比如跨父域子域进行AJAX访问，多个域名时如何跨域进行身份验证等）</p>

<p>从上面的例子很容易理解，uid是一个cookie的名称(name)，用于唯一标识一个具体的cookie，但cookie的名称是不区分大小写的，例如uid和UID标识了同一个cookie；而123则是该cookie的值(value)，除了名值外，cookie还包含域、路径、失效时间等信息，所有这些信息都可以通过前端或后端两个途径进行设置，下面讨论浏览器端的cookie操作（服务器端如何设置cookie不是我们的重点）。</p>

<p>在浏览器上我们通过对<code>document.cookie</code>属性的存取来操作cookie。随便打开一个网页，在chrome控制台中键入<code>document.cookie</code>后回车即可以看到此页面下可用的完整的cookie内容，会是个如下形式的值：</p>

<p><code>"xsrf=3779292c; uid=EPACMJGJBNKKLOFF; Serial=27EA"</code></p>

<p>可以看到<code>document.cookie</code>属性是一些由分号分割的名值对组成的字符串，如果要设置一个cookie，我们可以这样做：</p>

<p><code>document.cookie="uid1=123"</code></p>

<p>这时我们创建了名为uid1，值为123的cookie，<code>document.cookie</code>并不仅仅是一个普通的字符串，这个属性有着很奇怪的特性，虽然上面的语句看起来是赋值语句，但却不会覆盖cookie原来的值，而是会将新cookie添加到后面，创建完毕后的<code>document.cookie</code>会是这样：</p>

<p><code>"xsrf=3779292c; uid=EPACMJGJBNKKLOFF; Serial=27EA";uid1=123</code></p>

<p>可以看到新创建的cookie添加到后面了，但由于直接访问<code>document.cookie</code>只能获取到完整的字符串，要进一步获取具体的键值对就必须得手工操作这个字符串，为了方便地操作cookie，我们可以封装名两个函数，名为getCookie和setCookie：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function getCookie(name) {
</span><span class='line'>  var cookieName = encodeURIComponent(name) + "=",
</span><span class='line'>    cookieStart = document.cookie.indexOf(cookieName),
</span><span class='line'>    cookieValue = null,
</span><span class='line'>    cookieEnd;
</span><span class='line'>
</span><span class='line'>  if(cookieStart &gt; -1) {
</span><span class='line'>    cookieEnd = document.cookie.indexOf(";", cookieStart)
</span><span class='line'>    if(cookieEnd == -1) {
</span><span class='line'>      cookieEnd = document.cookie.length
</span><span class='line'>    }
</span><span class='line'>    cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd))
</span><span class='line'>  }
</span><span class='line'>  return cookieValue
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>function setCookie(name, value, opt_expires, opt_path, opt_domain, opt_secure) {
</span><span class='line'>  var cookieText = encodeURIComponent(name) + "=" + encodeURIComponent(value)
</span><span class='line'>
</span><span class='line'>  if(opt_expires instanceof Date) {
</span><span class='line'>    cookieText += "; expires=" + opt_expires.toGMTString()
</span><span class='line'>  }
</span><span class='line'>  if(opt_path) {
</span><span class='line'>    cookieText += "; path=" + opt_path
</span><span class='line'>  }
</span><span class='line'>  if(opt_domain) {
</span><span class='line'>    cookieText += "; domain=" + opt_domain
</span><span class='line'>  }
</span><span class='line'>  if(opt_secure) { // 安全标志，指定该标志后只有在使用 SSL 连接时才会发送cookie（即发送到https://开头的域）
</span><span class='line'>    cookieText += "; secure"
</span><span class='line'>  }
</span><span class='line'>  document.cookie = cookieText
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>代码完整展示了如何存取一个具体的cookie，之所以在每个过程都使用<code>encodeURIComponent</code>和<code>decodeURIComponent</code>对名值对儿进行编解码是为了确保cookie能被正确发送到服务器，setCookie函数中只有key和value是必须的，domain等参数可选且不会发送到服务器，比如现在要想获取名uid的cookie值，并在后面加上4，我们可以这样做：
<code>setCookie('uid', getCookie('uid') + 4)</code>
如果要删除一个cookie，我们只需要将key的值设置为空字符串，并将它的过期时间设置为过去的时间即可，由此可以得到下面这个unsetCookie 函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function unsetCookie(name, path, domain, secure) {
</span><span class='line'>  setCookie(name, "", new Date(0), path, domain, secure);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如此一来这个蹩脚的接口已经变得很方便开发人员操作了。</p>

<p>除了前面提到的域限制以外，Cookie还有一些其他的限制，其中比较重要的便是大小和数量限制。不同浏览器在实现cookie时，采用了不同的限制策略。常见浏览器在cookie数量上的限制如下：</p>

<ul>
<li>IE6 及更低版本每个域最多20个cookie。</li>
<li>IE7 及更高版本每个域最多50个cookie。</li>
<li>Firefox 每个域最多50个cookie。</li>
<li>Opera 为每个域30个cookie。</li>
<li>Webkit内核（Safari &amp; chrome）没有对cookie数量做明确限制，但是如果cookie太大以至于超过了HTTP头部大小限制时，服务器将无法正确处理。</li>
</ul>


<p>为了突破cookie个数限制，可以采用一种名为子cookie的技术，其基本原理是在一个cookie内存储多个名值对，限于篇幅，本书不再详述。</p>

<p>除了数量限制，浏览器对cookie的尺寸也做了限制，大多数浏览器都将cookie的尺寸限制在 4096B 左右 。</p>

<p>虽然cookie会存在用户磁盘里，但严格地说cookie并不能算是本地存储技术。因为每次请求站点的所有cookie都会被发送到服务器，如果将太多数据存放在cookie当中会严重降低传输性能，加上cookie本身还有大小和数量限制，所以cookie并不适合在客户端存储数据。如果要在本地存储大量数据，还得另寻其他方式。而 HTML5 规范中的 Web Storage 便是专门为大量本地数据的存储设计的。</p>

<h4>localStorage &amp; sessionStorage</h4>

<p>Storage在浏览器中被实现为一个类型，但开发者是不被允许实例化Storage对象的，浏览器已经内置有两个对象，一个是sessionStorage，另一个是localStorage，其中sessionStorage中存储的数据只在单个页面的会话期间有效，sessionStorage更类似于一个页面上的全局变量，而localStorage的数据则会被持久化到客户端，而且永远不会过期（cookie是可以设置过期时间的），并且其容量也不像cookie那样受限，因此localStorage成为了我们存储本地数据的不二之选。来看一个简单的例子以了解其基本使用方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(window.localStorage) { // 检测浏览器是否支持 localStorage
</span><span class='line'>  // 存储几个键值对
</span><span class='line'>  localStorage['book'] = 'HTML5 development'
</span><span class='line'>  localStorage.setItem('author', 'filod lin')
</span><span class='line'>  localStorage.setItem('2012', 'end of the world')
</span><span class='line'>  // 读取它们
</span><span class='line'>  console.log(localStorage.getItem('book')) // HTML5 development
</span><span class='line'>  console.log(localStorage.author) // filod lin
</span><span class='line'>  console.log(localStorage['2012']) // end of the world
</span><span class='line'>  // 删除它们
</span><span class='line'>  delete localStorage['author']
</span><span class='line'>  console.log(localStorage['author']) // undefined
</span><span class='line'>  localStorage.removeItem('2012')
</span><span class='line'>  console.log(localStorage.getItem('2012')) // null
</span><span class='line'>  localStorage.clear() // 删除所有的key
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到使用localStorage读写数据很方便，既可以像操作普通JavaScript那样去存取，也可以使用<code>setItem</code>、<code>getItem</code>和<code>removeItem</code>方法来存、取和删除 key。要注意的是，localStorage和普通对象不同在于只能存储字符串，如果你试图存储其他类型的数据，将会被强制转换成字符串，下面的例子最后会在控制台打印出 [object Object]：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var author = {
</span><span class='line'>  'name': 'filod lin'
</span><span class='line'>}
</span><span class='line'>localStorage['author'] = author
</span><span class='line'>console.log(localStorage['author']) // [object Object]</span></code></pre></td></tr></table></div></figure>


<p>如果要存储JSON对象，则可以先使用JSON提供的 <code>parse</code> 和 <code>stringify</code> 方法对对象进行序列化和反序列化：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>localStorage['author'] = JSON.stringify(author)
</span><span class='line'>console.log(JSON.parse(localStorage['author']).name) // filod lin </span></code></pre></td></tr></table></div></figure>


<p>localStorage对象的关键便在于持久化数据，当我们关闭浏览器再打开网站，依然可以访问到这个域存储的数据。</p>

<p>由于localStorage与sessionStorage都是Storage的实例，你可以完全使用和localStorage相同的方式去使用sessionStorage，它们共享Storage接口提供的一组方法和属性：
- <code>setItem(key, value)</code> 设置一个key
- <code>getItem(key)</code>  获取一个key
- <code>removeItem(key)</code> 移除一个key
- <code>length</code> 类似数组length属性，用于访问Storage对象中item的数量
- <code>key(n)</code> 用于访问第 n 个 key 的名称，如 local
- <code>clear()</code> 清除当前域下的所有localStorage内容。
而sessionStorage和localStorage不同之处在于存取数据生命周期不一样，只要一直在这个域内连续访问，存储在sessionStorage的数据会一直存在，而一旦关闭页面或者浏览器后所有存储的内容便消失了（这意味着sessionStorage不会将数据存入磁盘）。</p>

<p>对Storage对象进行的所有修改都会触发文档上的storage事件。
其中事件对象会有以下属性：
- <code>domain</code>：发生变化的域名。
- <code>key</code>: 发生修改的键。
- <code>oldValue</code>: 修改前的值。
- <code>newValue</code>: 修改后的值（如果是删除一个键，则为null）
下面的代码展示了如何监听该事件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>document.addEventListener("storage", function(e) {
</span><span class='line'>  // 截止到目前为止，尚无浏览器完整实现这些事件属性
</span><span class='line'>  // console.log("Storage changed. Name '" + e.key + "' changed from '" + e.oldValue + "' to '" + e.newValue + "'")
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<p>sessionStorage和localStorage都会触发此事件，但无法区分究竟是谁触发的事件。
而且这个事件现目前尚有兼容性问题，所以不建议使用此事件。</p>

<p>要注意，IE8中的Web Storage有10MB 的存储容量限制，而Firefox、Google Chrome 和 Opera中每个域名可以存储5MB的数据，不过对于大多数的应用来说5MB已经足够了。另外，IE提供了一个非标准的remainingSpace 属性用于查看剩余多少可用空间（单位是字节），下面这个函数可以获取剩余容量的百分比：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function getRemainingSpacePercent() {
</span><span class='line'>  if(localStorage.remainingSpace) {
</span><span class='line'>    return localStorage.remainingSpace / 5000000 * 100
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果你想实现一些需要在本地存储数据的功能，比如记住用户偏好或个性化设置、恢复页面上次打开状态等等，Web Storage 会是一个绝佳的选择。下面我们来实现一个页面访问计数器练练手：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>本次访问已经查看过该页面 &lt;span id="count1"&gt;&lt;/span&gt; 次&lt;br /&gt;
</span><span class='line'>历史上你已经查看过该页面 &lt;span id="count2"&gt;&lt;/span&gt; 次&lt;br /&gt;
</span><span class='line'>&lt;button id="btn"&gt;清零&lt;/button&gt;
</span><span class='line'>&lt;script type="text/javascript"&gt;
</span><span class='line'>  function updateCounter () {
</span><span class='line'>    document.getElementById("count1").innerHTML = sessionStorage.pageLoadCount || 0;
</span><span class='line'>    document.getElementById("count2").innerHTML = localStorage.pageLoadCount || 0;
</span><span class='line'>  }
</span><span class='line'>  if(localStorage.getItem("pageLoadCount") === null ) {
</span><span class='line'>    localStorage.setItem("pageLoadCount", 0)
</span><span class='line'>  }
</span><span class='line'>  if(sessionStorage.getItem("pageLoadCount") === null ) {
</span><span class='line'>    sessionStorage.setItem("pageLoadCount", 0)
</span><span class='line'>  }
</span><span class='line'>  localStorage.pageLoadCount = parseInt(localStorage.getItem("pageLoadCount")) + 1 
</span><span class='line'>  sessionStorage.pageLoadCount = parseInt(sessionStorage.getItem("pageLoadCount")) + 1 
</span><span class='line'>  updateCounter()
</span><span class='line'>  document.getElementById("btn").onclick = function () {
</span><span class='line'>    localStorage.clear()
</span><span class='line'>    sessionStorage.clear()
</span><span class='line'>    updateCounter()
</span><span class='line'>  }
</span><span class='line'>&lt;/script&gt;</span></code></pre></td></tr></table></div></figure>


<p>打开这个页面后，不断刷新，你会看到两个次数都会不断上涨，而关闭浏览器后再打开，则只有历史计数还存在。点击清零则会将两个计数都置为零，另外在chrome或safari开发者工具中可以方便地查看、调试localStorage和sessionStorage：
<img src="http://pic.yupoo.com/filod/CmB3sa6C/12QgLG.jpg" alt="调试 localStorage和sessionStorage" />
Web Storage在桌面和移动设备的浏览器中都有很好的支持，除了Opera Mini 和IE8以下版本的浏览器外，基本上其他浏览器都可以完美支持。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">by <span class="fn">filod</span></span>

      








  


<time datetime="2012-10-24T10:19:00+08:00" pubdate data-updated="true">2012-10-24</time>
      


    </p>
    
      <div class="sharing">
  
  
  <div class="g-plusone" data-size="medium"></div>
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2012/08/24/zi-dong-pin-he-spritetu-pian-de-gong-ju-yu-keng/" title="Previous Post: css sprite 相关工具的相关研究">&laquo; css sprite 相关工具的相关研究</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>若你说话，便是好事</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/10/24/cong-wang-ye-%28web-page%29dao-ying-yong-%28app%29/">从网页（Web page）到 应用（APP）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/08/24/zi-dong-pin-he-spritetu-pian-de-gong-ju-yu-keng/">css sprite 相关工具的相关研究</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/22/zi-ding-yi-shang-chuan-an-niu/">自定义上传按钮样式 & ajax上传</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/18/rang-inlineyuan-su-zi-dong-huan-xing/">让内联（inline）元素自动换行</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/07/11/banjiazhici/">搬家至此</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - filod -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'filodisnothere';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://filod.github.com/blog/2012/10/24/cong-wang-ye-%28web-page%29dao-ying-yong-%28app%29/';
        var disqus_url = 'http://filod.github.com/blog/2012/10/24/cong-wang-ye-%28web-page%29dao-ying-yong-%28app%29/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>







</body>
</html>
