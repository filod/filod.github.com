<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[filod's not here]]></title>
  <link href="http://filod.github.com/atom.xml" rel="self"/>
  <link href="http://filod.github.com/"/>
  <updated>2012-10-24T11:35:49+08:00</updated>
  <id>http://filod.github.com/</id>
  <author>
    <name><![CDATA[filod]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[从网页（Web page）到 应用（APP）]]></title>
    <link href="http://filod.github.com/blog/2012/10/24/cong-wang-ye-%28web-page%29dao-ying-yong-%28app%29/"/>
    <updated>2012-10-24T10:19:00+08:00</updated>
    <id>http://filod.github.com/blog/2012/10/24/cong-wang-ye-(web-page)dao-ying-yong-(app)</id>
    <content type="html"><![CDATA[<h2>从网页（Web page）到 应用（APP）</h2>

<h3>Web 不能承受之重</h3>

<h4>Web的轻与重</h4>

<p>Web 一词在英文中的本意是网络、结网，而这个网络的节点，便是网页（Web page），在过去，网页通常就是一篇文档（Document），通常来说是 HTML 文档，当然也可以是其他类型的文档（PDF、XML、SVG等）。一篇文档就像一张纸一样，轻而薄，包含一定量的信息，通过互联网，这些信息被链接起来，供人分享和查阅——这便是最初的 Web ，一个轻巧而单纯的网络，但人们发现互联网这个好东西不只是能用来交换信息，它还可以做更多的事儿，于是 渐渐地 Web 被赋予了更多的职能：从学术论文的交流到普通人博客的撰写、从文献索引到网络购物、从邮件到论坛……功能越来越多，网页也越来越复杂，越来越重，整个Web似乎都在朝着客户端软件发展。</p>

<h4>整个世界都在APP</h4>

<p>为了满足人们对 Web 日益增长的需求，浏览器的功能也变得越来越强大，从最初只能看看文档的“浏览”器，到如今已成为和操作系统平级的系统软件（Chrome OS 便是一个旗帜鲜明的例子），浏览器的发展的迅猛与Web标准发展的迟滞形成了鲜明对比，而HTML5则成为推动标准迅速演进的重要转折点，HTML5标准中提出的一些特性使得实现复杂用户界面的Web程序更加容易和高效，例如applicationcache、manifest、localStorage等技术使基于浏览器的离线应用成为可能，定位API(geolocation api)可以轻松获取设备的地理位置，触摸事件让用户在网页上也可以做出手势指令……所有这一切技术似乎都意味这一件事情：浏览器APP的时代，已经悄然到来。</p>

<h3>本地存储升级</h3>

<h4>cookie 和 cookie 的局限</h4>

<p>HTTP 本身是一种无状态、无连接的协议，用户在浏览器上请求一个动作时，服务器不会知道用户上次动作做了什么，因此如果要存储诸如登录与否、已录入文本等状态信息是非常麻烦的，对于开发交互式的程序来说这很致命，而cookie技术的发明则满足了大部分的状态存储的需求。
从根本上来讲，cookie 其实就是一段存储在客户端（浏览器）的文本，我们既可以在服务器响应返回时设置cookie的值，也可以在前端通过 JavaScript 进行修改。</p>

<p>我们考虑一个最简单的登录场景来说明 cookie 是如何实现状态存储的，当你向百度服务器发送了你的用户名密码并且验证过你的身份之后，服务器端会在响应客户端时的 HTTP 包的包头中的加上一个cookie字段，这个字段则可能是类似 uid=123 的值，是服务器分配给你的标识符，这段文本将存储在你的计算机磁盘中，当你继续浏览百度的其他页面时，每次http请求都会带上cookie这个字段，这样服务器端就可以确认这个请求依然来自于登录后的你，从而从某种意义上来说“保存”了登录状态，这时读者可能要问了，不同网站登录时都会发送吗？那岂不是谷歌就可以知道我百度的账号了？当然不是，cookie的使用是有限制的，这个限制便来自于域，不同域间的cookie是不会影响也不可访问。（注：域限制是Cookie安全的基础，这个话题有很多值得深入讨论的点，比如跨父域子域进行AJAX访问，多个域名时如何跨域进行身份验证等）</p>

<p>从上面的例子很容易理解，uid是一个cookie的名称(name)，用于唯一标识一个具体的cookie，但cookie的名称是不区分大小写的，例如uid和UID标识了同一个cookie；而123则是该cookie的值(value)，除了名值外，cookie还包含域、路径、失效时间等信息，所有这些信息都可以通过前端或后端两个途径进行设置，下面讨论浏览器端的cookie操作（服务器端如何设置cookie不是我们的重点）。</p>

<p>在浏览器上我们通过对<code>document.cookie</code>属性的存取来操作cookie。随便打开一个网页，在chrome控制台中键入<code>document.cookie</code>后回车即可以看到此页面下可用的完整的cookie内容，会是个如下形式的值：</p>

<p><code>"xsrf=3779292c; uid=EPACMJGJBNKKLOFF; Serial=27EA"</code></p>

<p>可以看到<code>document.cookie</code>属性是一些由分号分割的名值对组成的字符串，如果要设置一个cookie，我们可以这样做：</p>

<p><code>document.cookie="uid1=123"</code></p>

<p>这时我们创建了名为uid1，值为123的cookie，<code>document.cookie</code>并不仅仅是一个普通的字符串，这个属性有着很奇怪的特性，虽然上面的语句看起来是赋值语句，但却不会覆盖cookie原来的值，而是会将新cookie添加到后面，创建完毕后的<code>document.cookie</code>会是这样：</p>

<p><code>"xsrf=3779292c; uid=EPACMJGJBNKKLOFF; Serial=27EA";uid1=123</code></p>

<p>可以看到新创建的cookie添加到后面了，但由于直接访问<code>document.cookie</code>只能获取到完整的字符串，要进一步获取具体的键值对就必须得手工操作这个字符串，为了方便地操作cookie，我们可以封装名两个函数，名为getCookie和setCookie：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function getCookie(name) {
</span><span class='line'>  var cookieName = encodeURIComponent(name) + "=",
</span><span class='line'>    cookieStart = document.cookie.indexOf(cookieName),
</span><span class='line'>    cookieValue = null,
</span><span class='line'>    cookieEnd;
</span><span class='line'>
</span><span class='line'>  if(cookieStart &gt; -1) {
</span><span class='line'>    cookieEnd = document.cookie.indexOf(";", cookieStart)
</span><span class='line'>    if(cookieEnd == -1) {
</span><span class='line'>      cookieEnd = document.cookie.length
</span><span class='line'>    }
</span><span class='line'>    cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd))
</span><span class='line'>  }
</span><span class='line'>  return cookieValue
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>function setCookie(name, value, opt_expires, opt_path, opt_domain, opt_secure) {
</span><span class='line'>  var cookieText = encodeURIComponent(name) + "=" + encodeURIComponent(value)
</span><span class='line'>
</span><span class='line'>  if(opt_expires instanceof Date) {
</span><span class='line'>    cookieText += "; expires=" + opt_expires.toGMTString()
</span><span class='line'>  }
</span><span class='line'>  if(opt_path) {
</span><span class='line'>    cookieText += "; path=" + opt_path
</span><span class='line'>  }
</span><span class='line'>  if(opt_domain) {
</span><span class='line'>    cookieText += "; domain=" + opt_domain
</span><span class='line'>  }
</span><span class='line'>  if(opt_secure) { // 安全标志，指定该标志后只有在使用 SSL 连接时才会发送cookie（即发送到https://开头的域）
</span><span class='line'>    cookieText += "; secure"
</span><span class='line'>  }
</span><span class='line'>  document.cookie = cookieText
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>代码完整展示了如何存取一个具体的cookie，之所以在每个过程都使用<code>encodeURIComponent</code>和<code>decodeURIComponent</code>对名值对儿进行编解码是为了确保cookie能被正确发送到服务器，setCookie函数中只有key和value是必须的，domain等参数可选且不会发送到服务器，比如现在要想获取名uid的cookie值，并在后面加上4，我们可以这样做：
<code>setCookie('uid', getCookie('uid') + 4)</code>
如果要删除一个cookie，我们只需要将key的值设置为空字符串，并将它的过期时间设置为过去的时间即可，由此可以得到下面这个unsetCookie 函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function unsetCookie(name, path, domain, secure) {
</span><span class='line'>  setCookie(name, "", new Date(0), path, domain, secure);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如此一来这个蹩脚的接口已经变得很方便开发人员操作了。</p>

<p>除了前面提到的域限制以外，Cookie还有一些其他的限制，其中比较重要的便是大小和数量限制。不同浏览器在实现cookie时，采用了不同的限制策略。常见浏览器在cookie数量上的限制如下：</p>

<ul>
<li>IE6 及更低版本每个域最多20个cookie。</li>
<li>IE7 及更高版本每个域最多50个cookie。</li>
<li>Firefox 每个域最多50个cookie。</li>
<li>Opera 为每个域30个cookie。</li>
<li>Webkit内核（Safari &amp; chrome）没有对cookie数量做明确限制，但是如果cookie太大以至于超过了HTTP头部大小限制时，服务器将无法正确处理。</li>
</ul>


<p>为了突破cookie个数限制，可以采用一种名为子cookie的技术，其基本原理是在一个cookie内存储多个名值对，限于篇幅，本书不再详述。</p>

<p>除了数量限制，浏览器对cookie的尺寸也做了限制，大多数浏览器都将cookie的尺寸限制在 4096B 左右 。</p>

<p>虽然cookie会存在用户磁盘里，但严格地说cookie并不能算是本地存储技术。因为每次请求站点的所有cookie都会被发送到服务器，如果将太多数据存放在cookie当中会严重降低传输性能，加上cookie本身还有大小和数量限制，所以cookie并不适合在客户端存储数据。如果要在本地存储大量数据，还得另寻其他方式。而 HTML5 规范中的 Web Storage 便是专门为大量本地数据的存储设计的。</p>

<h4>localStorage &amp; sessionStorage</h4>

<p>Storage在浏览器中被实现为一个类型，但开发者是不被允许实例化Storage对象的，浏览器已经内置有两个对象，一个是sessionStorage，另一个是localStorage，其中sessionStorage中存储的数据只在单个页面的会话期间有效，sessionStorage更类似于一个页面上的全局变量，而localStorage的数据则会被持久化到客户端，而且永远不会过期（cookie是可以设置过期时间的），并且其容量也不像cookie那样受限，因此localStorage成为了我们存储本地数据的不二之选。来看一个简单的例子以了解其基本使用方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(window.localStorage) { // 检测浏览器是否支持 localStorage
</span><span class='line'>  // 存储几个键值对
</span><span class='line'>  localStorage['book'] = 'HTML5 development'
</span><span class='line'>  localStorage.setItem('author', 'filod lin')
</span><span class='line'>  localStorage.setItem('2012', 'end of the world')
</span><span class='line'>  // 读取它们
</span><span class='line'>  console.log(localStorage.getItem('book')) // HTML5 development
</span><span class='line'>  console.log(localStorage.author) // filod lin
</span><span class='line'>  console.log(localStorage['2012']) // end of the world
</span><span class='line'>  // 删除它们
</span><span class='line'>  delete localStorage['author']
</span><span class='line'>  console.log(localStorage['author']) // undefined
</span><span class='line'>  localStorage.removeItem('2012')
</span><span class='line'>  console.log(localStorage.getItem('2012')) // null
</span><span class='line'>  localStorage.clear() // 删除所有的key
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>可以看到使用localStorage读写数据很方便，既可以像操作普通JavaScript那样去存取，也可以使用<code>setItem</code>、<code>getItem</code>和<code>removeItem</code>方法来存、取和删除 key。要注意的是，localStorage和普通对象不同在于只能存储字符串，如果你试图存储其他类型的数据，将会被强制转换成字符串，下面的例子最后会在控制台打印出 [object Object]：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var author = {
</span><span class='line'>  'name': 'filod lin'
</span><span class='line'>}
</span><span class='line'>localStorage['author'] = author
</span><span class='line'>console.log(localStorage['author']) // [object Object]</span></code></pre></td></tr></table></div></figure>


<p>如果要存储JSON对象，则可以先使用JSON提供的 <code>parse</code> 和 <code>stringify</code> 方法对对象进行序列化和反序列化：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>localStorage['author'] = JSON.stringify(author)
</span><span class='line'>console.log(JSON.parse(localStorage['author']).name) // filod lin </span></code></pre></td></tr></table></div></figure>


<p>localStorage对象的关键便在于持久化数据，当我们关闭浏览器再打开网站，依然可以访问到这个域存储的数据。</p>

<p>由于localStorage与sessionStorage都是Storage的实例，你可以完全使用和localStorage相同的方式去使用sessionStorage，它们共享Storage接口提供的一组方法和属性：
- <code>setItem(key, value)</code> 设置一个key
- <code>getItem(key)</code>  获取一个key
- <code>removeItem(key)</code> 移除一个key
- <code>length</code> 类似数组length属性，用于访问Storage对象中item的数量
- <code>key(n)</code> 用于访问第 n 个 key 的名称，如 local
- <code>clear()</code> 清除当前域下的所有localStorage内容。
而sessionStorage和localStorage不同之处在于存取数据生命周期不一样，只要一直在这个域内连续访问，存储在sessionStorage的数据会一直存在，而一旦关闭页面或者浏览器后所有存储的内容便消失了（这意味着sessionStorage不会将数据存入磁盘）。</p>

<p>对Storage对象进行的所有修改都会触发文档上的storage事件。
其中事件对象会有以下属性：
- <code>domain</code>：发生变化的域名。
- <code>key</code>: 发生修改的键。
- <code>oldValue</code>: 修改前的值。
- <code>newValue</code>: 修改后的值（如果是删除一个键，则为null）
下面的代码展示了如何监听该事件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>document.addEventListener("storage", function(e) {
</span><span class='line'>  // 截止到目前为止，尚无浏览器完整实现这些事件属性
</span><span class='line'>  // console.log("Storage changed. Name '" + e.key + "' changed from '" + e.oldValue + "' to '" + e.newValue + "'")
</span><span class='line'>})</span></code></pre></td></tr></table></div></figure>


<p>sessionStorage和localStorage都会触发此事件，但无法区分究竟是谁触发的事件。
而且这个事件现目前尚有兼容性问题，所以不建议使用此事件。</p>

<p>要注意，IE8中的Web Storage有10MB 的存储容量限制，而Firefox、Google Chrome 和 Opera中每个域名可以存储5MB的数据，不过对于大多数的应用来说5MB已经足够了。另外，IE提供了一个非标准的remainingSpace 属性用于查看剩余多少可用空间（单位是字节），下面这个函数可以获取剩余容量的百分比：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function getRemainingSpacePercent() {
</span><span class='line'>  if(localStorage.remainingSpace) {
</span><span class='line'>    return localStorage.remainingSpace / 5000000 * 100
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>如果你想实现一些需要在本地存储数据的功能，比如记住用户偏好或个性化设置、恢复页面上次打开状态等等，Web Storage 会是一个绝佳的选择。下面我们来实现一个页面访问计数器练练手：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>本次访问已经查看过该页面 &lt;span id="count1"&gt;&lt;/span&gt; 次&lt;br /&gt;
</span><span class='line'>历史上你已经查看过该页面 &lt;span id="count2"&gt;&lt;/span&gt; 次&lt;br /&gt;
</span><span class='line'>&lt;button id="btn"&gt;清零&lt;/button&gt;
</span><span class='line'>&lt;script type="text/javascript"&gt;
</span><span class='line'>  function updateCounter () {
</span><span class='line'>    document.getElementById("count1").innerHTML = sessionStorage.pageLoadCount || 0;
</span><span class='line'>    document.getElementById("count2").innerHTML = localStorage.pageLoadCount || 0;
</span><span class='line'>  }
</span><span class='line'>  if(localStorage.getItem("pageLoadCount") === null ) {
</span><span class='line'>    localStorage.setItem("pageLoadCount", 0)
</span><span class='line'>  }
</span><span class='line'>  if(sessionStorage.getItem("pageLoadCount") === null ) {
</span><span class='line'>    sessionStorage.setItem("pageLoadCount", 0)
</span><span class='line'>  }
</span><span class='line'>  localStorage.pageLoadCount = parseInt(localStorage.getItem("pageLoadCount")) + 1 
</span><span class='line'>  sessionStorage.pageLoadCount = parseInt(sessionStorage.getItem("pageLoadCount")) + 1 
</span><span class='line'>  updateCounter()
</span><span class='line'>  document.getElementById("btn").onclick = function () {
</span><span class='line'>    localStorage.clear()
</span><span class='line'>    sessionStorage.clear()
</span><span class='line'>    updateCounter()
</span><span class='line'>  }
</span><span class='line'>&lt;/script&gt;</span></code></pre></td></tr></table></div></figure>


<p>打开这个页面后，不断刷新，你会看到两个次数都会不断上涨，而关闭浏览器后再打开，则只有历史计数还存在。点击清零则会将两个计数都置为零，另外在chrome或safari开发者工具中可以方便地查看、调试localStorage和sessionStorage：
<img src="http://pic.yupoo.com/filod/CmB3sa6C/12QgLG.jpg" alt="调试 localStorage和sessionStorage" />
Web Storage在桌面和移动设备的浏览器中都有很好的支持，除了Opera Mini 和IE8以下版本的浏览器外，基本上其他浏览器都可以完美支持。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[css sprite 相关工具的相关研究]]></title>
    <link href="http://filod.github.com/blog/2012/08/24/zi-dong-pin-he-spritetu-pian-de-gong-ju-yu-keng/"/>
    <updated>2012-08-24T20:54:00+08:00</updated>
    <id>http://filod.github.com/blog/2012/08/24/zi-dong-pin-he-spritetu-pian-de-gong-ju-yu-keng</id>
    <content type="html"><![CDATA[<h1>导读</h1>

<p><strong>sprite</strong> 图一种常见的css优化手段，但手工完成这项工作难免枯燥，于是有各种大牛发明了各种自动化或者半自动化的工具来解决这一问题。</p>

<p>从要解决的问题来讲，工具们在被制造时有如下几个出发点：</p>

<ol>
<li>有一堆小图片，如何生成一张大图和现成的 css。</li>
<li>有一张大图片，如何知道大图片中的小图片对应的 css。</li>
<li>有一堆小图片，以及写好的css，如何生成一张大图和对应的css。</li>
</ol>


<p><a href="http://cn.spritegen.website-performance.org/">css sprites</a>、<a href="http://alloyteam.github.com/gopng/">gopng</a>、<a href="https://github.com/jakesgordon/sprite-factory">sprite-factory</a>这几种工具对应出发点1，<a href="http://www.spritecow.com/">spritecow</a>对应出发点2，<a href="https://github.com/iazrael/ispriter">ispriter</a>则对应3。</p>

<!-- more -->


<h2>应用和原理</h2>

<h4>有一堆小图片，如何生成一张大图和现成的 css？</h4>

<p><strong>css sprites</strong>似乎最早是腾讯的鬼哥基于C#写的工具版，后来搬到了<a href="http://cn.spritegen.website-performance.org/">网上</a>，<a href="http://alloyteam.github.com/gopng/">gopng</a> 则似乎是css sprites的HTML5版继任者*。它们的基本原理是读取图片，然后基于<a href="https://github.com/jakesgordon/bin-packing">一些算法</a>把小图片拼合为一张大图片，拼合的同时记录小图片在大图片中的位置，以此生成对应的css代码。<a href="https://github.com/jakesgordon/sprite-factory">sprite-factory</a>则类似，不过因为是开源的命令行工具，相较于前两者而言你可以方便地集成到自己项目的build代码中。</p>

<p><em>*没去考证，总之这俩工具都是腾讯的哥哥们搞的</em></p>

<h4>有一张大图片，如何知道大图片中的小图片对应的 css？</h4>

<p><a href="http://www.spritecow.com/">spritecow</a>是一个比较半自动化的工具，你如果有一张大图片的话，可以通过spritecow自动定位大图片中的小图片的<code>position</code>，并生成该小图片相应的css，简单易用，用用便知，基本原理的话则与上一种做法相反。</p>

<h4>有一堆小图片，以及写好的css，如何生成一张大图和对应的css。</h4>

<p>如果很不幸，你手头已经有一堆图片，一堆写好的css，以及一堆使用着这些css的HTML代码，显然前述两种做法对你而言只能是做“加法”，而不易全部推倒，还好有<a href="https://github.com/iazrael/ispriter">ispriter</a>这个工具，这个工具相较于前两者，多了一个css分析步骤，可以在不影响已有css的情况下，生成大图和css，具体的使用和原理可以<a href="http://imatlas.com/posts/nodejs-intelligent-merge-css-sprite/">看看这篇文章</a>。</p>

<h2>我们的需求</h2>

<p>除了文章开始的提到的三种需求，可能更多人会遇到这种困扰（这篇博文就源于此）：</p>

<p>有<strong>一些</strong>不大不小图片，它们都有着已经写好的css sprites代码，随着星转斗移，<strong>一些</strong>不大不小的图片变成了<strong>一堆</strong>，这时候，你想把它们合到一张图片中去，你也不想更改你的css代码和HTML代码，而且最好一个按钮，一切搞定。</p>

<p><strong>答案是，一键清理，不可能——或者说，极其困难。</strong></p>

<p>所以，在这种情况下想寻求懒方法的朋友可以关掉浏览器了，再见不送~:P</p>

<p>下面详细分析下产生限制的原因和权衡的解法。</p>

<h3>为什么不可能</h3>

<p>好，首先假设你已经认认真真看完了关于ispriter的文章，关于基本原理和用法就差不多明白了，不过多介绍。
如果你已经有一堆，基于这种原理进行自动拼合 sprite 时，会遇到以下限制：</p>

<p><strong>1. 重复属性定义.  </strong></p>

<p>以这种常见情况为例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">background</span><span class="nd">:-moz-linear-gradient</span><span class="o">(</span><span class="nt">top</span><span class="o">,</span><span class="nf">#adda4d</span><span class="o">,</span><span class="nf">#86b846</span><span class="o">);</span>
</span><span class='line'><span class="nt">background</span><span class="nd">:-webkit-gradient</span><span class="o">(</span><span class="nt">linear</span><span class="o">,</span><span class="nt">0</span> <span class="nt">0</span><span class="o">,</span><span class="nt">0</span> <span class="nt">100</span><span class="o">%,</span><span class="nt">from</span><span class="o">(</span><span class="nf">#adda4d</span><span class="o">),</span><span class="nt">to</span><span class="o">(</span><span class="nf">#86b846</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为<code>CSSOM</code>解析器不可能针对某一种前缀来保存解析后的样式表，所以像重复定义但是有多个前缀以适应不同浏览器的样式，<code>CSSOM</code>解析器在解析css代码时会覆盖重复的属性定义，解析出的<code>cssRules</code>中将只包含最后定义的属性（因为剥离了浏览器，所以也不会识别<code>-webkit-</code>这样的前缀），最后经过处理再输出了<code>cssText</code>就会“信息不完整”。</p>

<p>so，这意味着，如果要完美实现这个 auto sprite 的功能，得修改 cssom 的解析器让其保存所有重复定义（这违背了 css 的运行时应用规则 - -b），想了想难度， 我决定作罢。</p>

<p>so，在限制下，只能搞搞单独的 <code>sprite.css</code> 了</p>

<p><strong>2. 写法限制 </strong></p>

<p>isprite 是处理单张小图片用的，如果要处理多张已经sprite的图片，</p>

<p>考虑这样一种我们<em>已有</em>的 sprite 代码的 常见情况：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nc">.icon-another</span><span class="p">{</span>
</span><span class='line'>  <span class="k">background-image</span><span class="o">:</span> <span class="sx">url(&quot;icon1.png&quot;)</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nc">.icon</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">background-image</span><span class="o">:</span> <span class="sx">url(&quot;icon2.png&quot;)</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nc">.z-icon-follow</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">width</span><span class="o">:</span> <span class="m">8px</span><span class="p">;</span>
</span><span class='line'>  <span class="k">height</span><span class="o">:</span> <span class="m">9px</span><span class="p">;</span>
</span><span class='line'>  <span class="k">background-position</span><span class="o">:</span> <span class="m">-88px</span> <span class="m">-137px</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nc">.z-icon-fold</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">width</span><span class="o">:</span> <span class="m">8px</span><span class="p">;</span>
</span><span class='line'>  <span class="k">height</span><span class="o">:</span> <span class="m">9px</span><span class="p">;</span>
</span><span class='line'>  <span class="k">background-position</span><span class="o">:</span> <span class="m">-101px</span> <span class="m">-136px</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>用sprite拼合后的代码类似这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nc">.icon-another</span><span class="p">{</span>
</span><span class='line'>  <span class="k">background-image</span><span class="o">:</span> <span class="sx">url(&quot;sprite-another.png&quot;)</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nc">.icon</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">background-image</span><span class="o">:</span> <span class="sx">url(&quot;sprite.png&quot;)</span><span class="p">;</span>
</span><span class='line'>  <span class="k">background-position</span><span class="o">:</span> <span class="m">-20px</span> <span class="m">-100px</span><span class="p">;</span> <span class="c">/* 此时的 `background-position` 依赖于拼合的图片的位置  */</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nc">.z-icon-follow</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">width</span><span class="o">:</span> <span class="m">8px</span><span class="p">;</span>
</span><span class='line'>  <span class="k">height</span><span class="o">:</span> <span class="m">9px</span><span class="p">;</span>
</span><span class='line'>  <span class="k">background-position</span><span class="o">:</span> <span class="m">-88px</span> <span class="m">-137px</span><span class="p">;</span> <span class="c">/* 注意，这里没变！*/</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nc">.z-icon-fold</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">width</span><span class="o">:</span> <span class="m">8px</span><span class="p">;</span>
</span><span class='line'>  <span class="k">height</span><span class="o">:</span> <span class="m">9px</span><span class="p">;</span>
</span><span class='line'>  <span class="k">background-position</span><span class="o">:</span> <span class="m">-101px</span> <span class="m">-136px</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>很容易看出问题在于，在解析和处理css规则的时候，我们根本无法得知 <code>.z-icon-follow</code> 这条规则究竟会使用哪张图片——配合使用<code>.icon</code>还是<code>.icon-another</code>？而且，即使
我们已经写了很多的 sprite 代码都采用了这样的写法，<a href="http://twitter.github.com/bootstrap">bootstrap</a>里的所有 sprite也是这样写的，遵循这样的写法和使用方法，如果真要实现自动sprite，则需要：</p>

<ul>
<li>拟定规则，在处理css的时候对没有<code>background-image</code>的css规则应用指定的<code>background-image</code>，而且还得根据已有的<code>background-position</code>和在最后生成的大图中小图的位置计算出最终icon的<code>background-image</code>（好拗口,>_&lt;）。</li>
<li>或者扫描HTML文件，知道所有的class是如何使用的（基本上是个不可能任务，因为你的HTML代码很可能是模板生成的）</li>
</ul>


<p>所以，基本上，呃……(⊙o⊙)…</p>

<h3>所以没辙了吗？</h3>

<p>不是已经说了么，“一键XX”是不可能的。XD。所以真是这样的时候，重构你的代码和图片吧。对于大型或者持续开发的项目，出发点1 所限的开发方式是比较稳妥的。</p>

<hr />

<h5>别的 sprite 思路？</h5>

<p>有个很特别的sprite 方式，是利用data:url，具体做法和相关优缺点请参考下面的文章：
<a href="http://www.cssforest.org/blog/index.php?id=152">Data URI的利弊</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义上传按钮样式 & ajax上传]]></title>
    <link href="http://filod.github.com/blog/2012/07/22/zi-ding-yi-shang-chuan-an-niu/"/>
    <updated>2012-07-22T17:11:00+08:00</updated>
    <id>http://filod.github.com/blog/2012/07/22/zi-ding-yi-shang-chuan-an-niu</id>
    <content type="html"><![CDATA[<p>自定义上传按钮这个是个老生常谈的问题了，之前在工作中碰到过，简单记录一下。<br/>
实现基本原理是将<code>input[file]</code>表单的透明度设置为0，然后外层用<code>label</code>标签覆盖里层<code>input</code>，按钮样式写在<code>lable</code>当中，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nc">.transparent-file</span><span class="p">{</span>
</span><span class='line'>    <span class="k">opacity</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span>
</span><span class='line'>    <span class="o">-</span><span class="n">moz</span><span class="o">-</span><span class="k">opacity</span><span class="o">:</span> <span class="m">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">filter</span><span class="o">:</span><span class="n">alpha</span><span class="p">(</span><span class="k">opacity</span><span class="o">=</span><span class="m">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">position</span><span class="o">:</span> <span class="k">absolute</span><span class="p">;</span>
</span><span class='line'>    <span class="k">width</span><span class="o">:</span><span class="m">88px</span><span class="p">;</span>
</span><span class='line'>    <span class="k">height</span><span class="o">:</span><span class="m">32px</span><span class="p">;</span>
</span><span class='line'>    <span class="k">top</span><span class="o">:</span><span class="m">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">left</span><span class="o">:</span><span class="m">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nc">.file-lable</span><span class="p">{</span>
</span><span class='line'>    <span class="k">position</span><span class="o">:</span> <span class="k">relative</span><span class="p">;</span> <span class="c">/* 使用定位让lable 和 input 重合 */</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nc">.button</span><span class="p">{</span>
</span><span class='line'>    <span class="c">/* 你具体button的样式 */</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;label</span> <span class="na">for=</span><span class="s">&quot;&quot;</span> <span class="na">class=</span><span class="s">&quot;file-lable button&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">&quot;file&quot;</span> <span class="na">class=</span><span class="s">&quot;transparent-file&quot;</span> <span class="na">name=</span><span class="s">&quot;picture&quot;</span>  <span class="nt">/&gt;</span>
</span><span class='line'>    上传头像
</span><span class='line'><span class="nt">&lt;/label&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
如果你要实现<strong>ajax上传</strong>效果，则可以利用一个隐藏的<code>iframe</code>作为上传<code>form</code>的<code>target</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;iframe</span> <span class="na">src=</span><span class="s">&quot;about:blank&quot;</span> <span class="na">id=</span><span class="s">&quot;iframe&quot;</span> <span class="na">name=</span><span class="s">&quot;iframe&quot;</span> <span class="na">style=</span><span class="s">&quot;display:none&quot;</span> <span class="nt">&gt;&lt;/iframe&gt;</span>
</span><span class='line'><span class="nt">&lt;form</span>  <span class="na">id=</span><span class="s">&quot;form-id&quot;</span> <span class="na">action=</span><span class="s">&quot;/upload&quot;</span> <span class="na">enctype=</span><span class="s">&quot;multipart/form-data&quot;</span> <span class="na">target=</span><span class="s">&quot;iframe&quot;</span>  <span class="na">method=</span><span class="s">&quot;post&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="c">&lt;!-- 上传按钮在这儿 --&gt;</span>
</span><span class='line'><span class="nt">&lt;/form&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>其原理是在那个<code>iframe</code>中发起post请求，这样就可以实现ajax上传的效果啦<em>（注意enctype)</em></p>

<p>如果要实现<strong>选择文件后自动上传</strong>的效果，则需要为file表单绑定<code>change</code>事件，当选择文件后会触发<code>change</code>事件，此时调用<code>form</code>元素的<code>submit</code>方法即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">$file</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s2">&quot;change&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">(){</span>
</span><span class='line'>  <span class="nx">$form</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">submit</span><span class="p">()</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意!</strong> <em>之前我有个思路是把<code>input</code>隐藏掉，同时在单击另一个button的时候触发这个隐藏<code>input</code>的<code>click</code>事件，实时证明是可以的，但是却有兼容性问题：</em>
在IE下，触发了<code>change</code>事件后，自动调用是<code>submit</code>方法将会报错！</p>

<p>与此同时我写了一个jQuery的小插件：</p>

<!-- more -->


<div><script src='https://gist.github.com/3159053.js?file='></script>
<noscript><pre><code>/**
 * @description jquery img 上传插件 for zhihu ~
 * @requires [jquery]
 * @author filod &lt;ll@zhihu.com&gt;
 */
(function($, undefined) {
    var ImgUploader = function(formEl, options) {
            this.isie = true ;
            this.option = $.extend({}, $.fn.imgUploader.defaults, options)
            this.$msg = $('&lt;span&gt;&lt;/span&gt;')
            this.$file = $(this.option.fileCls)
            this.$doBtn = $(this.option.doCls)
            this.$form = $(formEl).on('uploadchange', $.proxy(this.doneCallback, this));
            this.$file.on(&quot;change&quot;, $.proxy(this.upload, this)); 
        }
    ImgUploader.prototype = {
        constructor: ImgUploader,
        upload: function(e) {
            var self = this
            if (!self.checkUploadImageType(this.$file.val())) {
                self.setMessage(&quot;图片不是 . jpg  .png 或 .gif 格式，无法上传&quot;);
                return
            }
            if(this.isie){
                this.$form[0].submit()
                return
            }
        },
        postForm: function (e) {
            this.$form[0].submit()
            return false
        },
        checkUploadImageType: function(fileName) {
            fileName = fileName + &quot;&quot;;
            if (!fileName || fileName.length &lt; 3) {
                return false;
            }
            fileName = fileName.toLowerCase();
            for (var i = this.option.allowType.length - 1; i &gt;= 0; i--) {
                if(!endsWith(fileName,this.option.allowType[i])){
                    continue
                }else{
                    return true
                }
            };
            return false
        },
        setMessage : function  (msg) {
            this.$msg.html(msg).insertBefore(this.$form)
        },
        doneCallback : function(e, data) {
            if(data.r === 1){ //上传失败了
                this.setMessage(data.msg)
            }else if(data.r === 0){ 
                this.setMessage('')
                $('.avatar-preview').attr('src',data.msg)
            }
        }
    }
    function endsWith(str, suffix) {
        var l = str.length - suffix.length;
        return l &gt;= 0 &amp;&amp; str.indexOf(suffix, l) == l;
    }

    $.fn.imgUploader = function(option) {
        return this.each(function() {
            var $this = $(this),
                data = $this.data('scrollspy'),
                options = typeof option == 'object' &amp;&amp; option
            if (!data) {
                $this.data('imagloader', (data = new ImgUploader(this,option)))
            }
        })
    }
    $.fn.imgUploader.defaults = {
        doCls: '.do-upload',
        fileCls: '.avatar-file',
        allowType : ['jpg','gif','jpeg','png']
    }
})(jQuery);
</code></pre></noscript></div>


<p>当然，这是针对公司特定应用的，如果要使用到自己的项目中还得修改一下。用法是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#form-id&#39;</span><span class="p">).</span><span class="nx">imgUploader</span><span class="p">();</span> <span class="c1">//option defalt 见源码</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果<code>iframe</code>有回调则可以在回调中调用<code>$('#avatar-form').trigger('uploadchange',data);</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让内联（inline）元素自动换行]]></title>
    <link href="http://filod.github.com/blog/2012/07/18/rang-inlineyuan-su-zi-dong-huan-xing/"/>
    <updated>2012-07-18T15:09:00+08:00</updated>
    <id>http://filod.github.com/blog/2012/07/18/rang-inlineyuan-su-zi-dong-huan-xing</id>
    <content type="html"><![CDATA[<p>有时候我们需要让一个内联元素在新行显示，方法无非这样几种：</p>

<ol>
<li><strong>直接对该元素 <code>display:block</code></strong><br/>
这样做的问题在于，如果你要处理的元素是链接，那么这整行都变得可以点击了。</li>
<li><strong>在元素外套上一层 <code>div</code></strong><br/>
嗯，基本上满足大部分需要。</li>
<li><strong>不增加标签，直接用css实现。</strong><br/>
因为新老系统要做兼容，如果采用方法2，则需要在代码中新增模板来区分对待，如果能通过css选择器区分不同情况下的a标签如何显示当然是最好了的，其实只通过css也可以直接做到:</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nc">.xx-wrap</span> <span class="nt">a</span><span class="nd">:before</span><span class="p">{</span>
</span><span class='line'>    <span class="k">content</span><span class="o">:</span> <span class="s1">&#39;\a&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">white-space</span><span class="o">:</span> <span class="n">pre</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>解释一下，斜杠A（\a）表示unicode中的换行符，换行符属于“空白符”（white-space）的一种，<code>white-space</code>属性用于控制空白符如何显示，<code>white-space: pre</code>则意味着换行符的显示方式和在<code>pre</code>标签中一致（即该怎样显示，就怎样显示），关于<code>white-space</code>的其他用法可以参考<a href="http://www.w3school.com.cn/css/pr_text_white-space.asp">这里</a>。整个表达式的意思是在a的前面隐式加上一个换行。</p>

<p><em>更多内容可以参考<a href="http://cheeaun.com/blog/2005/06/whitespace-and-generated-content">Whitespace and generated content</a></em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搬家至此]]></title>
    <link href="http://filod.github.com/blog/2012/07/11/banjiazhici/"/>
    <updated>2012-07-11T12:08:00+08:00</updated>
    <id>http://filod.github.com/blog/2012/07/11/banjiazhici</id>
    <content type="html"><![CDATA[<h2>why here ?</h2>

<p>没有为什么，只是常年没写blog了，搬个地儿，刺激一下自己。</p>

<h2>better place ?</h2>

<p>或许吧，呵呵（皮笑）</p>

<h2>then ?</h2>

<p>what ?</p>

<h3>老博客呢？</h3>

<p>为确保数据不丢失，在俩地方做了backup：</p>

<p><a href="http://filodoldblog.sinaapp.com">sae上的备份</a></p>

<p><a href="http://blogold.filod.net">原始备份（格式更优）</a></p>
]]></content>
  </entry>
  
</feed>
